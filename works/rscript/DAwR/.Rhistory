# [9] NA  "j" <- 백터 s에 재할당 하지 않았기 때문.
s <- s[-10]
print(x = s)
## 벡터 원소 변경
# === 인덱싱과 슬라이싱을 이용한 변경 ===
s[1] <- 'A'
print(x = s)
s[2] <- 'B'
print(x = s)
s[1:2] <- c('가','나')
print(x = s)
## 벡터생성
# === 실수형, 정수형 벡터 생성 ===
a <- c(1, 2, 3)
print(x = a)
class(x = a) # "numeric" 실수형
b <- c(1L, 2L, 3L)
print(x = b)
class(x = b) # "integer" 정수형
# 정수형 벡터만 입력받는 R 함수에 실수형 벡터를 저장하면 에러 발생. 자료형과 자료구조를 미리 확인하는 습관 기르기.
print(x = 101:150)
# [1] 101 102 103 104 105 106 107
# [8] 108 109 110 111 112 113 114
#[15] 115 116 117 118 119 120 121
#[22] 122 123 124 125 126 127 128
#[29] 129 130 131 132 133 134 135
#[36] 136 137 138 139 140 141 142
#[43] 143 144 145 146 147 148 149
#[50] 150
# []로 출력되면 해당 객체는 벡터.
# []안의 값은 해당 줄 첫 원소의 인덱스 값.
# === 문자형, 논리형 벡터 생성 ===
c <- c('hello', 'world')
class(x = c) # "character"
d <- c(FALSE, TRUE)
class(x = d) # "logical"
print(x = T) # TRUE, 따옴표 없음.
T <- F
print(x = T) # FALSE
# F, T는 FALSE, TRUE의 축약형이므로 객체명으로 사용하지 않는것이 권장됨.
# === 빈 벡터 생성 ===
c()
# for문에 사용
# === 범주형 벡터 생성 ===
# factor(x = 범주형으로 전환할 벡터,
#        levels = 범주형 벡터의 레벨 순서인 문자형 벡터)
# as.factor(x = 벡터) 기존 벡터를 범주형 벡터로 변경할 때 사용. 레벨 순서 변경 불가.
nat <- c('한국', '일본', '중국', '미국', '중국', '한국', '미국', '일본')
print(x = nat)
# [1] "한국" "일본" "중국" "미국"
# [5] "중국" "한국" "미국" "일본"
fct <- as.factor(x = nat) # 범주화
print(x = fct)
# [1] 한국 일본 중국 미국 중국 한국
# [7] 미국 일본
# Levels: 미국 일본 중국 한국
# 각 원소에 따옴표가 사라지고 levels 추가적으로 출력됨.
as.integer(x = fct)
# [1] 4 2 3 1 3 4 1 2
# 범주형 벡터 fct를 전수형 벡터로 전환 할 수 있음.
# 범주형 벡터가 정수형 또는 실수형 벡터로 변환되면서 원솟값이 레벨의 위치 번호인 인덱스로 바뀜.
# 범주형 벡터로 변환 시 레벨 순서 지정도 가능.
fct <- factor(x = nat, levels = c('한국', '미국', '중국', '일본'))
print(x = fct)
as.integer(x = fct)
# [1] 1 4 3 2 3 1 2 4 <- levels 순서 변경
# === 원소가 연속되는 벡터 생성 ===
# seq(from = 처음 숫자,
#     to = 마지막 숫자,
#     by = 간격,
#     length.out = 반환되는 벡터의 길이)
# seq(from = 1, to = 3, by = 1)
# 1:3
seq(1,3,1); seq(3)
seq(from = 3, to = 1, by = -1) # [1] 3 2 1
seq(from = 1, to = 10, by = 2.5) # [1] 1.0 3.5 6.0 8.5
seq(from = 1, to = 10, length = 19)
#  [1]  1.0  1.5  2.0  2.5  3.0  3.5
#  [7]  4.0  4.5  5.0  5.5  6.0  6.5
# [13]  7.0  7.5  8.0  8.5  9.0  9.5
# [19] 10.0
seq(1, 10, length = 19)
#  [1]  1.0  1.5  2.0  2.5  3.0  3.5
#  [7]  4.0  4.5  5.0  5.5  6.0  6.5
# [13]  7.0  7.5  8.0  8.5  9.0  9.5
# [19] 10.0
seq(1,3,1, length.out = 5)
# === 범주형 벡터 원소 변경 ===
nat[8] <- '대만'
print(x = nat)
fct[8] <- '대만'
# Warning message:
#     In `[<-.factor`(`*tmp*`, 8, value = "대만") :
#     요인의 수준(factor level)이 올바르지 않아 NA가 생성되었습니다.
print(x = fct)
levels(x = fct)
levels(x = fct)[5] <- '대만'
fct[8] <- '대만
fct[8] <- '대만'
print(x = fct)
levels(x = fct)
levels(x = fct)[5] <- '대만'
fct[8] <- '대만'
print(x = fct)
print(x = fct)
as.integer(x = 1.2)
as.integer(x = '1.2')
as.integer(x = F)
as.integer(x = T)
as.integer(x = T) #
as.integer(x = TRUE) #
as.integer(x = FALSE) #
as.integer(x = T)
as.numeric(x = 1L)
as.numeric(x = '1.2')
as.numeric(x = TRUE)
# === 문자혈로 형변환 ===
as.character(x =1L)
as.character(x = 1.2)
as.character(x= TRUE)
as.losical(x = 0)
as.logical(x = 0)
as.logical(x = 1.2)
as.logical(x = '1.2')
e <- as.factor(x = c)
print(x = e)
# [1] hello world
# Levels: hello world
class(x = e)
as.integer(x = e)
## 벡터 강제변환
c <- c('hello', 'world')
d <- c(F,T)
e <- as.factor(x = c)
f <- c(d, e)
print(x = f)
class(x = f)
f <- c(f, '4')
print(x = f)
class(x = f)
class(x = f) # [1] "character" <- 문자형 '4'가 추가되어 벡터 f의 자료형이 문자형으로 형변환 됨.
a <- (0, 2, 4)
a <- c(0, 2, 4)
b <- c(1, 2, 3)
a+b
a-b
c <- seq(1,11,2)
d <- seq(3,12,3)
a+c
a+d
]  3  8 13 12
a+1
# === 곰셈, 나눗셈, 나머지, 몫, 거듭제곱 연산 ===
a*2
a^2
a / 2
a %% 2
a %/% 2
# TRUE/FALSE로 갑 반환
a > 2
a >= 2
a < 2
a <= 2
a == 2
a != 2
## 논리 연산자
a >= 1
b <= 2
a >= 1 ! b <= 2
## 논리 연산자
a >= 1
b <= 2
a >= 1 & b <= 2 # 모두 T -> T
a >= 1 | b <= 2 # 모두 F -> F
a >= 1 ! b <= 2 # T -> F, F -> T
!(a >= 1 & b <= 2) # T -> F, F -> T
x <- 0
x == a[2]
x == a[3]
x == a[1]
x == a[1] | x == a[2] | x == a[3]
x %in% a # 멤버 연산자 왼쪽에 있는 벡터의 원소가 멤버 연산자 오른쪽에 있는 벡터의 원소가 포함되면 TRUE, 아니면 FALSE 반환
num <- seq(from = 1, to = 10, by = 2)
cha <- rep(x = c('a', 'b'), each = 3)
lst1 <- list(num, cha)
print(x = lst1)
# [[1]]
# [1] 1 3 5 7 9
#
# [[2]]
# [1] "a" "a" "a" "b" "b" "b"
class(x = lst1)
str(object = lst1)
length(x = lst1)
lst2 <- list(a = num, b = cha, c = lst1)
print(x = lst2)
#
# $b
# [1] "a" "a" "a" "b" "b" "b"
#
# $c
# $c[[1]]
# [1] 1 3 5 7 9
#
# $c[[2]]
# [1] "a" "a" "a" "b" "b" "b"
class(x = lst2)
str(object = lst2)
lst1$a
lst2$a
lst1[[1]]
lst2[[2,3]]
# 어떤 함수를 실해했을 때 리스트가 생성되었다면 str() 함수를 실행하여 리스트 구조를 빠르게 파악
# 리스트의 일부만 선택하여 다음 작업을 진행해 나가는 것이 일반적이기 때문
# lm() <- 선형 회귀 모형 생성시 리스트 반환
fit <- lm(formula = weight ~ height. data = woman)
lst2[1]
# $a
# [1] 1 3 5 7 9 <- 리스트 반환
lst2[c(1, 3)]
lst2$d <- 1:5
str(object = lst2)
lst2$a <- NULL
str(object = lst2)
lst2$b <- letters[1:5]
print(x = lst2$b)
lst2$b[1] <- 'A'
print(x = lst2$b)
num <- seq(from = 1, to = 10, by = 2)
chr <- rep(x = c('a', 'b'), each = 3)
df1 <- data.frame(num, chr)
cha <- letters[1:5]
df1 <- data.frame(num,cha)
print(x = df1)
#   num cha
# 1   1   a
# 2   3   b
# 3   5   c
# 4   7   d
# 5   9   e
class(x = df1)
str(object = df1)
options('max.print')
View(x = df1)
View(df1)
View(df1)
View(df1)
# 데이터프레임 생성시 문자형 벡터 자동변환 옵션
options('stringsAsFactors')
df2 <- data.frame(num, cha, stringsAsFactors = TRUE)
str(object = df2)
## 데이터프레임 원소 선택
# === 인덱싱으로 선택 ===
df1[1,1]
df1[1:2, 1:2]
df1[1, ]
df1[1:2, ]
df1[, 1]
df1[, 1:2]
df1[, 1, drop = FALSE]
df1[, 'num']
df1[, c('num', 'cha')]
df1$ㅜㅕㅡ
df1$num
df1$cha
df1$num >= 5
df1[df1$num >= 5, ]
# 데이터프레임에서 괄호 안 조건을 만족하는 행과 하나의 열을 선택하는 두 가지 방법
df1[df1$num >= 5, 'cha']
df1$cha[df1$num >= 5]
df1$int <- 11:15
str(object = df1)
cbind(df1, rep(x = TRUE, times = 5))
cbind(df1, log = rep(x = TRUE, times = 5))
str(object = df1)
df1 <- cbind(df1, log = rep(x = TRUE, times = 5))
str(object = df1)
df3 <- data.frame(num = 6, cha = 'f', int = 16, log = TRUE)
rbind(df1, df3)
#   num cha int  log
# 1   1   a  11 TRUE
# 2   3   b  12 TRUE
# 3   5   c  13 TRUE
# 4   7   d  14 TRUE
# 5   9   e  15 TRUE
# 6   6   f  16 TRUE
str(object = df1)
str(object = df1)
df1$num <- NULL
str(object = df1)
# === 행 또는 열 삭제 ===
dfq[-1, -1]
# === 행 또는 열 삭제 ===
df1[-1, -1]
df1[-1, ]
df1[, -1]
df$cha <- letters[1:5]
df1$cha <- letters[1:5]
print(x = df1)
df1$int[1] <- '11'
str(object = df1)
df1$int[1] <- '21'
str(object = df1)
df1$int[1] <- '11'
str(object = df1)
obj <- 1L
class(x = obj)
class(x = obj) == 'integer'
print(x = '정수입니다.')
print(x = '정수입니다!')
obj <- as.character(x = obj)
print(x = '정수입니다!')
obj <- as.character(x = obj)
if (class(x = obj) == 'integer') {
print(x = '정수입니다!')
}
print(x = '정수입니다!')
if (class(x = obj) == 'integer') {
print(x = '정수입니다!')
} else {
print(x = '정수가 아닙니다.')
}
print(x = '정수가 아닙니다!')
print(x = '숫자가 아닙니다!')
if (class(x = obj) == 'integer') {
print(x = '정수입니다!')
} else if (class(x = obj) == 'numeric') {
print(x = '실수입니다!')
} else {
print(x = '숫자가 아닙니다!')
}
score <- 10
if (score >= 70) {
grade <- '합격'
} else {
grade <- '불합격'
}
print(x = grade)
score <- c(100,69)
if (score >= 70) {
grade <- '합격'
} else {
grade <- '불합격'
}
print(x = grade) # [1] "불합격"
score <- c(100,69)
if (score >= 70) {
grade <- '합격'
} else {
grade <- '불합격'
} # Error in if (score >= 70) { : the condition has length > 1
print(x = grade) # [1] "불합격"
score <- c(100,69)
if (score >= 70) {
grade <- '합격'
} else {
grade <- '불합격'
} # Error in if (score >= 70) { : the condition has length > 1
print(x = grade) # [1] "불합격"
score <- c(100,69)
if (score >= 70) {
grade <- '합격'
} else {
grade <- '불합격'
} # Error in if (score >= 70) { : the condition has length > 1
score <- c(100,69)
if (score >= 70) {
grade <- '합격'
} else {
grade <- '불합격'
} # Error in if (score >= 70) { : the condition has length > 1
print(x = grade) # [1] "불합격"
score <- c(100,79)
if (score >= 70) {
grade <- '합격'
} else {
grade <- '불합격'
} # Error in if (score >= 70) { : the condition has length > 1
print(x = grade) # [1] "불합격"
score <- c(100,69)
if (score >= 70) {
grade <- '합격'
} else {
grade <- '불합격'
} # Error in if (score >= 70) { : the condition has length > 1
score <- c(100,69)
if (score >= 70) {
grade <- '합격'
} else {
grade <- '불합격'
} # Error in if (score >= 70) { : the condition has length > 1
print(x = grade) # [1] "불합격" ????? 첫번 째 요소만 사용해서 합격이어야 하는거 아님? 바뀐건가?
score <- c(100,69)
if (score >= 70) {
grade <- '합격'
} else {
grade <- '불합격'
}
print(x = grade)
score <-  seq(from = 40, to = 100, by = 10)
print(score)
score >= 70
ifelse(test = score >= 70, yes = '합격', no = '불합격')
df <- data.frame(score)
str(object = df)
df$grade <- ifelse(test = d$score >= 70, yes = '합격', no = '불합격')
df$grade <- ifelse(test = df$score >= 70, yes = '합격', no = '불합격')
print(x = df)
menu <- c('짜장면', '탕수육', '깐풍기', '짬뽕', '전가복', '샥스핀')
print(x = item)
for (item in menu) {
print(x = item)
}
item
for (item in menu) {
item
}
item
item
# [1] "짜장면"
# [1] "탕수육"
# [1] "깐풍기"
# [1] "짬뽕"
# [1] "전가복"
# [1] "샥스핀"
for (item in menu) {
item
}
item
item
item
print(item, '시킬까요?\n')
cat(객체명, 문자열, ... , sep = " ")
for (item in menu) {
cat(item, '시킬까요?\n')
}
for (item in menu) {
text <- paste(item, '시킬까요?\n')
print(x = text)
}
i <- 5
while (i > 0) {
print(x = i)
i <- i - 1
}
for (item in menu) {
if (item %in% c('짜장면', '짬뽕')) {
cat(item, '요리부터 주문합시다!\n', sep = '? ')
} else {
cat(item, '다음 메뉴는 뭔가요?\n', sep = '? ')
}
}
for (item in menu) {
if(item %in% c('짜장면', '짬뽕')) {
next
cat(item, '요리부터 주문합시다!\n', sep = '? ')
} else {
cat(item, '다음 메뉴는 뭔가요?\n', sep = '? ')
}
}
# === while문에서 break ===
i <- 0
while (TRUE) {
print(x = i)
i <- i + 1
if(i > 5) {
break
}
}
for (i in 0:9) {
print(x = i)
if(i > 5) {
break
}
}
i <- 0
repeat {
print(x = i)
i <- i + 1
if (i > 5) {
break
}
}
Pythagoras <- function (a, b) {
c <- sprt (x = a^2 + b^2)
return(c)
}
Pythagoras(a = 3, b = 4)
Pythagoras <- function (a, b) {
c <- sprt(x = a^2 + b^2)
return(c)
}
Pythagoras(a = 3, b = 4)
Pythagoras <- function (a, b) {
c <- sprt (x = a^2 + b^2)
return(c)
}
Pythagoras(a = 3, b = 4)
install.packages('kknn')
library(kknn)
Pythagoras <- function (a, b) {
c <- sprt (x = a^2 + b^2)
return(c)
}
Pythagoras(a = 3, b = 4)
install.packages("kknn")
library(kknn)
Pythagoras <- function (a, b) {
c <- sprt (x = a^2 + b^2)
return(c)
}
Pythagoras(a = 3, b = 4)
