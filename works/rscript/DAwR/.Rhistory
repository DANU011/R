a <- 1
b <- 2
a <- b
b <- 3
print(x = a); print(x = b)
la <- 3
1a <- 3
`1a` <- 3
print(x = `1a`)
print(x = `2a`)
`2a` <- 4
print(x = `2a`)
a <- c(1, 2, 3)
print(x = a)
class(x = a)
print(x = b)
class(x = b)
b <- c(1L, 2L, 3L)
print(x = b)
class(x = b)
source("~/.active-rstudio-document")
print(x = 101:150)
# 문자형, 논리형 벡터 생성
c <- c('hello', 'world')
class(x = c)
fct <- factor(x = nat, levels = c('한국', '미국', '중국', '일본'))
print(x = nat)
nat <- c('한국', '일본', '중국', '미국', '중국', '한국', '미국', '일본')
print(x = nat)
fct <- factor(x = nat, levels = c('한국', '미국', '중국', '일본'))
print(x = fct)
as.integer(x = fct)
seq(from = 1, to = 3, by = 1)
1:3
seq(from = 1, to = 10, by = 2.5)
seq(from = 1, to = 3, by = -1)
seq(from = 3, to = 1, by = -1)
seq(from = 1, to = 10, length = 19)
seq(from = 1, to = 10, by = 2.5)
# seq(from = 1, to = 3, by = 1)
# 1:3
seq(1,3,1)
# seq(from = 3, to = 1, by = -1) # [1] 3 2 1
seq(3,1,-1)
# seq(from = 3, to = 1, by = -1) # [1] 3 2 1
seq(3)
# seq(from = 1, to = 3, by = 1)
# 1:3
seq(1,3,1);seq(3)
seq(1,3,1, length.out = 5)
# Error in seq.default(1, 3, 1, length.out = 5) : 너무 많은 인자들이 있습니다
seq(1,3,length.out = 5)
# [1] 1.0 1.5 2.0 2.5 3.0
seq(1,3,length = 5)
#  [1]  1.0  1.5  2.0  2.5  3.0  3.5
#  [7]  4.0  4.5  5.0  5.5  6.0  6.5
# [13]  7.0  7.5  8.0  8.5  9.0  9.5
# [19] 10.0
seq(1, 10, length = 19)
rep(x = 1, times = 3)
rep(x = 1:3, times = 3)
rep(x = 1:3, each = 3)
rep(x = 1:3, length = 10)
#x, times는 생략 가능
req(1:3, 3)
rep(1:3, each = 2)
#x, times는 생략 가능
rep(1:3, 3)
rep(x = 1:3, 3, each = 2)
rep(x = 1:3, 3, each = 2, length = 18)
rep(x = 1:3, 3, each = 2, length = 10)
source("C:/Users/DA/GitHub/R/works/rscript/chap02.R")
# R 내장 문자형 벡터 letters
print(x = letters)
#  [1] "a" "b" "c" "d" "e" "f" "g" "h"
#  [9] "i" "j" "k" "l" "m" "n" "o" "p"
# [17] "q" "r" "s" "t" "u" "v" "w" "x"
# [25] "y" "z"
# R의 인덱스는 0부터 시작, a:b b까지 포함
letters[1]
s <- letters[1:5]
print(x = s)
s[c(1,2,3)]
s[c(T,F,T,F,T)]
s[6] <- 'f'
print(x = s)
s[10]
print(x = s)
s[10] <- 'j'
print(x = s)
## 벡터 원소 삭제
s[-10]
print(x = s)
# [1] "a" "b" "c" "d" "e" "f" NA  NA
# [9] NA  "j" <- 백터 s에 재할당 하지 않았기 때문.
s <- s[-10]
print(x = s)
## 벡터 원소 변경
# === 인덱싱과 슬라이싱을 이용한 변경 ===
s[1] <- 'A'
print(x = s)
s[2] <- 'B'
print(x = s)
s[1:2] <- c('가','나')
print(x = s)
## 벡터생성
# === 실수형, 정수형 벡터 생성 ===
a <- c(1, 2, 3)
print(x = a)
class(x = a) # "numeric" 실수형
b <- c(1L, 2L, 3L)
print(x = b)
class(x = b) # "integer" 정수형
# 정수형 벡터만 입력받는 R 함수에 실수형 벡터를 저장하면 에러 발생. 자료형과 자료구조를 미리 확인하는 습관 기르기.
print(x = 101:150)
# [1] 101 102 103 104 105 106 107
# [8] 108 109 110 111 112 113 114
#[15] 115 116 117 118 119 120 121
#[22] 122 123 124 125 126 127 128
#[29] 129 130 131 132 133 134 135
#[36] 136 137 138 139 140 141 142
#[43] 143 144 145 146 147 148 149
#[50] 150
# []로 출력되면 해당 객체는 벡터.
# []안의 값은 해당 줄 첫 원소의 인덱스 값.
# === 문자형, 논리형 벡터 생성 ===
c <- c('hello', 'world')
class(x = c) # "character"
d <- c(FALSE, TRUE)
class(x = d) # "logical"
print(x = T) # TRUE, 따옴표 없음.
T <- F
print(x = T) # FALSE
# F, T는 FALSE, TRUE의 축약형이므로 객체명으로 사용하지 않는것이 권장됨.
# === 빈 벡터 생성 ===
c()
# for문에 사용
# === 범주형 벡터 생성 ===
# factor(x = 범주형으로 전환할 벡터,
#        levels = 범주형 벡터의 레벨 순서인 문자형 벡터)
# as.factor(x = 벡터) 기존 벡터를 범주형 벡터로 변경할 때 사용. 레벨 순서 변경 불가.
nat <- c('한국', '일본', '중국', '미국', '중국', '한국', '미국', '일본')
print(x = nat)
# [1] "한국" "일본" "중국" "미국"
# [5] "중국" "한국" "미국" "일본"
fct <- as.factor(x = nat) # 범주화
print(x = fct)
# [1] 한국 일본 중국 미국 중국 한국
# [7] 미국 일본
# Levels: 미국 일본 중국 한국
# 각 원소에 따옴표가 사라지고 levels 추가적으로 출력됨.
as.integer(x = fct)
# [1] 4 2 3 1 3 4 1 2
# 범주형 벡터 fct를 전수형 벡터로 전환 할 수 있음.
# 범주형 벡터가 정수형 또는 실수형 벡터로 변환되면서 원솟값이 레벨의 위치 번호인 인덱스로 바뀜.
# 범주형 벡터로 변환 시 레벨 순서 지정도 가능.
fct <- factor(x = nat, levels = c('한국', '미국', '중국', '일본'))
print(x = fct)
as.integer(x = fct)
# [1] 1 4 3 2 3 1 2 4 <- levels 순서 변경
# === 원소가 연속되는 벡터 생성 ===
# seq(from = 처음 숫자,
#     to = 마지막 숫자,
#     by = 간격,
#     length.out = 반환되는 벡터의 길이)
# seq(from = 1, to = 3, by = 1)
# 1:3
seq(1,3,1); seq(3)
seq(from = 3, to = 1, by = -1) # [1] 3 2 1
seq(from = 1, to = 10, by = 2.5) # [1] 1.0 3.5 6.0 8.5
seq(from = 1, to = 10, length = 19)
#  [1]  1.0  1.5  2.0  2.5  3.0  3.5
#  [7]  4.0  4.5  5.0  5.5  6.0  6.5
# [13]  7.0  7.5  8.0  8.5  9.0  9.5
# [19] 10.0
seq(1, 10, length = 19)
#  [1]  1.0  1.5  2.0  2.5  3.0  3.5
#  [7]  4.0  4.5  5.0  5.5  6.0  6.5
# [13]  7.0  7.5  8.0  8.5  9.0  9.5
# [19] 10.0
seq(1,3,1, length.out = 5)
# === 범주형 벡터 원소 변경 ===
nat[8] <- '대만'
print(x = nat)
fct[8] <- '대만'
# Warning message:
#     In `[<-.factor`(`*tmp*`, 8, value = "대만") :
#     요인의 수준(factor level)이 올바르지 않아 NA가 생성되었습니다.
print(x = fct)
levels(x = fct)
levels(x = fct)[5] <- '대만'
fct[8] <- '대만
fct[8] <- '대만'
print(x = fct)
levels(x = fct)
levels(x = fct)[5] <- '대만'
fct[8] <- '대만'
print(x = fct)
print(x = fct)
as.integer(x = 1.2)
as.integer(x = '1.2')
as.integer(x = F)
as.integer(x = T)
as.integer(x = T) #
as.integer(x = TRUE) #
as.integer(x = FALSE) #
as.integer(x = T)
as.numeric(x = 1L)
as.numeric(x = '1.2')
as.numeric(x = TRUE)
# === 문자혈로 형변환 ===
as.character(x =1L)
as.character(x = 1.2)
as.character(x= TRUE)
as.losical(x = 0)
as.logical(x = 0)
as.logical(x = 1.2)
as.logical(x = '1.2')
e <- as.factor(x = c)
print(x = e)
# [1] hello world
# Levels: hello world
class(x = e)
as.integer(x = e)
## 벡터 강제변환
c <- c('hello', 'world')
d <- c(F,T)
e <- as.factor(x = c)
f <- c(d, e)
print(x = f)
class(x = f)
f <- c(f, '4')
print(x = f)
class(x = f)
class(x = f) # [1] "character" <- 문자형 '4'가 추가되어 벡터 f의 자료형이 문자형으로 형변환 됨.
a <- (0, 2, 4)
a <- c(0, 2, 4)
b <- c(1, 2, 3)
a+b
a-b
c <- seq(1,11,2)
d <- seq(3,12,3)
a+c
a+d
]  3  8 13 12
a+1
# === 곰셈, 나눗셈, 나머지, 몫, 거듭제곱 연산 ===
a*2
a^2
a / 2
a %% 2
a %/% 2
# TRUE/FALSE로 갑 반환
a > 2
a >= 2
a < 2
a <= 2
a == 2
a != 2
## 논리 연산자
a >= 1
b <= 2
a >= 1 ! b <= 2
## 논리 연산자
a >= 1
b <= 2
a >= 1 & b <= 2 # 모두 T -> T
a >= 1 | b <= 2 # 모두 F -> F
a >= 1 ! b <= 2 # T -> F, F -> T
!(a >= 1 & b <= 2) # T -> F, F -> T
x <- 0
x == a[2]
x == a[3]
x == a[1]
x == a[1] | x == a[2] | x == a[3]
x %in% a # 멤버 연산자 왼쪽에 있는 벡터의 원소가 멤버 연산자 오른쪽에 있는 벡터의 원소가 포함되면 TRUE, 아니면 FALSE 반환
num <- seq(from = 1, to = 10, by = 2)
cha <- rep(x = c('a', 'b'), each = 3)
lst1 <- list(num, cha)
print(x = lst1)
# [[1]]
# [1] 1 3 5 7 9
#
# [[2]]
# [1] "a" "a" "a" "b" "b" "b"
class(x = lst1)
str(object = lst1)
length(x = lst1)
lst2 <- list(a = num, b = cha, c = lst1)
print(x = lst2)
#
# $b
# [1] "a" "a" "a" "b" "b" "b"
#
# $c
# $c[[1]]
# [1] 1 3 5 7 9
#
# $c[[2]]
# [1] "a" "a" "a" "b" "b" "b"
class(x = lst2)
str(object = lst2)
lst1$a
lst2$a
lst1[[1]]
lst2[[2,3]]
# 어떤 함수를 실해했을 때 리스트가 생성되었다면 str() 함수를 실행하여 리스트 구조를 빠르게 파악
# 리스트의 일부만 선택하여 다음 작업을 진행해 나가는 것이 일반적이기 때문
# lm() <- 선형 회귀 모형 생성시 리스트 반환
fit <- lm(formula = weight ~ height. data = woman)
lst2[1]
# $a
# [1] 1 3 5 7 9 <- 리스트 반환
lst2[c(1, 3)]
lst2$d <- 1:5
str(object = lst2)
lst2$a <- NULL
str(object = lst2)
lst2$b <- letters[1:5]
print(x = lst2$b)
lst2$b[1] <- 'A'
print(x = lst2$b)
